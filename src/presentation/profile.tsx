import * as React from 'react';
import Add from '@mui/icons-material/Add';
import { Button, Divider } from '@mui/material';
import { Chip, Grid, Link } from '@mui/material';
import { Trans, useTranslation } from 'react-i18next';
import SystemUpdateAltIcon from '@mui/icons-material/SystemUpdateAlt';

import '@presentation/common.scss';
import { CODES } from '@src/common/codes';
import { REGEX } from '@src/common/REGEX';
import Bar from '@presentation/molecule/bar';
import inversify from '@src/common/inversify';
import { Input } from '@presentation/molecule/input';
import { Footer } from '@presentation/molecule/footer';
import PassKeyClientData from '@src/common/passKeyClientData';
import { passkeyStore } from '@presentation/store/passkeyStore';
import { FlashStore, flashStore} from '@presentation/molecule/flash';
import PassKeyClientDataValidation from '@src/common/passKeyClientDataValidation';
import { ContextStoreModel, contextStore } from '@presentation/store/contextStore';
import { UpdPasswordUsecaseModel } from '@usecase/updPassword/updPassword.usecase.model';

export const Profile = () => {
  const { t } = useTranslation();
  const flash:FlashStore = flashStore();
  const context:ContextStoreModel = contextStore();
  const [formEntities, setFormEntities] = React.useState({
    old: {
      value: '',
      valid: false
    },
    new: {
      value: '',
      valid: false
    },
    conf: {
      value: '',
      valid: false
    }
  });
  const [qry, setQry] = React.useState({
    loading: false,
    data: null,
    error: null
  });

  const update = () => {
    setQry(qry => ({
      ...qry,
      error: null,
      loading: true
    }));

    inversify.updPasswordUsecase.execute({
      old_value: formEntities.old.value,
      new_value: formEntities.new.value,
      conf_value: formEntities.conf.value
    })
      .then((response:UpdPasswordUsecaseModel) => {
        if(response.message === CODES.SUCCESS) {
          flash.open(t('profile.passwordUpdated'));
          setFormEntities({
            old: {
              value: '',
              valid: false
            },
            new: {
              value: '',
              valid: false
            },
            conf: {
              value: '',
              valid: false
            }
          });
        } else {
          inversify.loggerService.debug(response.error);
          setQry(qry => ({
            ...qry,
            error: response.message
          }));
        }
      })
      .catch((error:any) => {
        setQry(qry => ({
          ...qry,
          error: error.message
        }));
      })
      .finally(() => {
        setQry(qry => ({
          ...qry,
          loading: false
        }));
      });
  }

  const formIsValid = () => {
    if (!formEntities.new.valid || !formEntities.old.valid || !formEntities.conf.valid || (formEntities.new.value !== formEntities.conf.value)) {
      return false;
    }
    return true;
  }

  const createPassKeyCredential = async (
    username: string,
    displayName: string,
    challengeBufferString: string,
    userId: string
  ) => {
    /*
      The challenge is a buffer of randomly generated bytes with a minimum of 16 bytes. 
      This is generated on the server using a cryptographically secure random number generator. 
      By generating the challenge on the server we can prevent "replay attacks". 
      The authenticator will sign this along with other data.
    */
    const challengeBuffer = Uint8Array.from(
      challengeBufferString as string,
      (c) => c.charCodeAt(0)
    );
  
    const userIdBuffer = Uint8Array.from(userId, (c) => c.charCodeAt(0));
  
    const publicKeyCredentialCreationOptions: PublicKeyCredentialCreationOptions =
      {
        challenge: challengeBuffer,
        rp: {
          name: 'siguri',
          id: location.hostname,
        },
        user: {
          id: userIdBuffer,
          name: username,
          displayName: displayName,
        },
        // SUPPORT ALL PASSKEYS
        pubKeyCredParams: [
          {
            type: "public-key",
            alg: -7,
          },
          {
            type: "public-key",
            alg: -35,
          },
          {
            type: "public-key",
            alg: -36,
          },
          {
            type: "public-key",
            alg: -257,
          },
          {
            type: "public-key",
            alg: -258,
          },
          {
            type: "public-key",
            alg: -259,
          },
          {
            type: "public-key",
            alg: -37,
          },
          {
            type: "public-key",
            alg: -38,
          },
          {
            type: "public-key",
            alg: -39,
          },
          {
            type: "public-key",
            alg: -8,
          },
        ],
        timeout: 15000,
        attestation: "direct",
      };
  
    console.log(
      "✅  publicKeyCredentialCreationOptions : ",
      publicKeyCredentialCreationOptions
    );
  
    return await navigator.credentials.create({
      publicKey: publicKeyCredentialCreationOptions,
    });
  };

  const generateRandomString = (lengthOfString: number) => {
    var p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    return [...Array(lengthOfString)].reduce(
      (a) => a + p[~~(Math.random() * p.length)],
      ""
    ) as string;
  };

  const validatePassKeyCreation = (credential: Credential): string | null => {
    const clientDataValidation = validateClientData(credential);
    switch (clientDataValidation.valid) {
      case true:
        return clientDataValidation.challenge;
      case false:
        return null;
    }
  };

  const parseClientData = (clientData: ArrayBuffer) => {
    // decode the clientDataJSON into a utf-8 string
    const utf8Decoder = new TextDecoder("utf-8");
    const decodedClientData = utf8Decoder.decode(clientData);
  
    // parse the string as an object
    const clientDataObj = JSON.parse(decodedClientData);
    return clientDataObj as PassKeyClientData;
  };
  
  const validateClientData = (
    credential: Credential
  ): PassKeyClientDataValidation => {
    // @ts-ignore
    // Gather the Client Data
    const clientData = parseClientData(credential.response.clientDataJSON);
    const currentOrigin = window.location.href;
    console.log("✅  Gathered Client Data: ", clientData);
    if (!currentOrigin.includes(clientData.origin)) {
      console.log("❌  Origin does not match!");
      return {
        valid: false,
        challenge: null,
      };
    } else if (clientData.type !== "webauthn.create") {
      console.log("❌  Type does not match webauthn.create");
      return {
        valid: false,
        challenge: null,
      };
    }
    console.log("✅  Client Data is Valid");
    return {
      valid: true,
      challenge: clientData.challenge,
    };
  };

  const addPasskey = async () => {
    const challengeBufferString = generateRandomString(16);
    console.log("✅ Created challengeBufferString : ", challengeBufferString);
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* MARK: THIS SHOULD BE DONE IF AN ACCOUNT IS VALID 
             AND THE CHALLENGE BUFFER AND USERID SHOULD BE PASSED
             FROM THE RETURN CALL IN THE SERVER
    */
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    try {
      const credential = await createPassKeyCredential(context.code, `${context.name_first} ${context.name_last}`, challengeBufferString, context.id);

      if (credential) {
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // MARK: THIS SHOULD BE DONE ON THE BACKEND
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        console.log("✅ Credential is not null : ", credential);

        // Validate PassKey Creation
        const challenge = validatePassKeyCreation(credential);
        switch (challenge) {
          case null:
            console.log("❌ PassKey verification failed.");
            return;
          default:
            console.log(
              "✅ PassKey verification passed with challenge : ",
              challenge
            );

            const data = {
              user_id: context.id,
              user_code: context.code,
              display_name: `${context.name_first} ${context.name_last}`,
              challenge_buffer: challengeBufferString,
              challenge: challenge,
            };
            await inversify.createPasskeyUsecase.execute(data);
            passkeyStore.setState({ 
              user_code: data.user_code,
              challenge_buffer: data.challenge_buffer
            });
            console.log("✅ Save the user account data.", data)
          }
        } else {
          console.log("❌ Credential does not exist.");
        }
    } catch (error) {
      console.log("❌ Error creating credential");
      // Session Timed Out
      console.log("ERROR : ", error);
    }
  }

  let content = <div></div>;
  let errorMessage = <div></div>;

  if (qry.error) {
    errorMessage = <div><Trans>profile.{qry.error}</Trans></div>
  }

  if (qry.loading) {
    content = <Trans>common.loading</Trans>;
  } else {
    content = <form>
      <Grid
        container
      >
        <Grid
          item
          xs={6}
          display="flex"
          justifyContent="center"
          alignItems="center"
        >
          {/* Field old password */}
          <Input
            label={<Trans>profile.oldPassword</Trans>}
            tooltip={<Trans>REGEX.PASSWORD</Trans>}
            regex={REGEX.PASSWORD}
            type='password'
            entity={formEntities.old}
            onChange={(entity:any) => { 
              setFormEntities({
                ... formEntities,
                old: {
                  value: entity.value,
                  valid: entity.valid
                }
              });
            }}
            require
            virgin
          />
        </Grid>
        <Grid
          item
          xs={6}
          display="flex"
          justifyContent="center"
          alignItems="center"
        >
          {/* Field new password */}
          <Input
            label={<Trans>profile.newPassword</Trans>}
            tooltip={<Trans>REGEX.PASSWORD</Trans>}
            regex={REGEX.PASSWORD}
            type='password'
            entity={formEntities.new}
            onChange={(entity:any) => { 
              setFormEntities({
                ... formEntities,
                new: {
                  value: entity.value,
                  valid: entity.valid
                }
              });
            }}
            require
            virgin
          />
        </Grid>
        <Grid
          item
          xs={6}
          display="flex"
          justifyContent="center"
          alignItems="center"
        >
          {/* Field confirm password */}
          <Input
            label={<Trans>profile.confPassword</Trans>}
            tooltip={<Trans>REGEX.PASSWORD</Trans>}
            regex={REGEX.PASSWORD}
            type='password'
            entity={formEntities.conf}
            onChange={(entity:any) => { 
              setFormEntities({
                ... formEntities,
                conf: {
                  value: entity.value,
                  valid: entity.valid
                }
              });
            }}
            require
            virgin
          />
        </Grid>

        <Grid
          item
          xs={6}
          display="flex"
          justifyContent="center"
          alignItems="center"
        >
          {/* Submit button */}
          <Button 
            type="submit"
            variant="contained"
            size="small"
            startIcon={<SystemUpdateAltIcon />}
            disabled={!formIsValid()}
            onClick={(e) => { 
              e.preventDefault();
              update();
            }}
          ><Trans>common.done</Trans></Button>
        </Grid>
      </Grid>
    </form>
  }

  return (
    <div className="app">
      <Bar/>
      <div className="parent_container">
        <div className="container">
          <div className='title'>
            <Trans>profile.title</Trans>
          </div>
          <div>
            <Grid
              container
            >
              <Grid 
                xs={12}
                item
                display="flex"
                justifyContent="center"
                alignItems="center"
              >
                <Trans>profile.code</Trans>{context.code}
              </Grid>
              <Grid 
                xs={6}
                item
                display="flex"
                justifyContent="center"
                alignItems="center"
              >
                <Trans>profile.name_first</Trans>{context.name_first}
              </Grid>
              <Grid 
                xs={6}
                item
                display="flex"
                justifyContent="center"
                alignItems="center"
              >
                <Trans>profile.name_last</Trans>{context.name_last}
              </Grid>
            </Grid>
            <Divider>
              <Chip label={<Trans>profile.password</Trans>} size="small" />
            </Divider>
            {content}
            <Divider
              sx={{
                paddingBottom: 1
              }}
            >
              <Chip label={<Trans>profile.passkeys</Trans>} size="small" />
            </Divider>
            <Grid
              item
              xs={12}
              display="flex"
              justifyContent="center"
              alignItems="center"
            >
              {/* Add passkey */}
              <Button 
                variant="contained"
                size="small"
                startIcon={<Add />}
                onClick={(e) => { 
                  e.preventDefault();
                  addPasskey();
                }}
              ><Trans>profile.addPasskey</Trans></Button>
            </Grid>
            <Grid
              item
              xs={12}
              display="flex"
              justifyContent="center"
              alignItems="center"
            >
              <Link href="ms-settings:savedpasskeys"><Trans>profile.keys</Trans></Link>
            </Grid>
            <Grid
              item
              xs={12}
              display="flex"
              justifyContent="center"
              alignItems="center"
            >
              {errorMessage}
            </Grid>
          </div>
        </div>
      </div>
      <Footer />
    </div>
  )
};